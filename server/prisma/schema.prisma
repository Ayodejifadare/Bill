// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  directUrl         = env("DIRECT_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

model User {
  id                  String    @id @default(cuid())
  email               String    @unique
  name                String
  password            String    @default("")
  firstName           String?
  lastName            String?
  dateOfBirth         DateTime?
  address             String?
  bio                 String?
  phone               String?  @unique
  googleId            String?  @unique
  avatar              String?
  balance             Float     @default(0)
  twoFactorEnabled    Boolean   @default(false)
  biometricEnabled    Boolean   @default(false)
  phoneVerified       Boolean   @default(false)
  emailVerified       Boolean   @default(false)
  idVerified          Boolean   @default(false)
  documentsSubmitted  Boolean   @default(false)
  kycStatus           String    @default("pending")
  tokenVersion        Int       @default(0)
  privacySettings     String?
  preferenceSettings  String?
  region              String    @default("US")
  currency            String    @default("USD")
  onboardingCompleted Boolean   @default(false)
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  // Relationships
  sentTransactions        Transaction[]           @relation("SentTransactions")
  receivedTransactions    Transaction[]           @relation("ReceivedTransactions")
  billSplits              BillSplit[]
  billSplitParticipants   BillSplitParticipant[]
  friendRequestsSent      FriendRequest[]         @relation("FriendRequestSender")
  friendRequestsReceived  FriendRequest[]         @relation("FriendRequestReceiver")
  friendships1            Friendship[]            @relation("User1")
  friendships2            Friendship[]            @relation("User2")
  groups                  GroupMember[]
  groupAccounts           GroupAccount[]
  paymentMethods          PaymentMethod[]
  notifications           Notification[]          @relation("NotificationRecipient")
  notificationPreference  NotificationPreference?
  notificationsActing     Notification[]          @relation("NotificationActor")
  paymentRequestsSent     PaymentRequest[]        @relation("PaymentRequestSender")
  paymentRequestsReceived PaymentRequest[]        @relation("PaymentRequestReceiver")
  securityLogs            SecurityLog[]
  verificationCodes       VerificationCode[]
  remindersSent           BillSplitReminder[]     @relation("BillSplitReminderSender")
  remindersReceived       BillSplitReminder[]     @relation("BillSplitReminderRecipient")
  paymentReferences       PaymentReference[]
  payLinks                PayLink[]

  @@map("users")
}

model Transaction {
  id          String   @id @default(cuid())
  amount      Float
  description String?
  status      String   @default("PENDING")
  type        String
  category    String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Foreign keys
  senderId    String
  receiverId  String
  billSplitId String?

  // Relationships
  sender    User       @relation("SentTransactions", fields: [senderId], references: [id])
  receiver  User       @relation("ReceivedTransactions", fields: [receiverId], references: [id])
  billSplit BillSplit? @relation(fields: [billSplitId], references: [id])

  receipts          Receipt[]
  invoices          Invoice[]
  paymentReferences PaymentReference[]

  @@map("transactions")
}

model PaymentRequest {
  id                 String    @id @default(cuid())
  amount             Float
  description        String?
  message            String?
  status             String    @default("PENDING")
  isRecurring        Boolean   @default(false)
  recurringFrequency String?
  recurringDay       Int?
  recurringDayOfWeek Int?
  nextDueDate        DateTime?
  // Link to the payer's payment method at the time of request (optional)
  paymentMethodId    String?
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  // Foreign keys
  senderId   String
  receiverId String

  // Relationships
  sender   User @relation("PaymentRequestSender", fields: [senderId], references: [id])
  receiver User @relation("PaymentRequestReceiver", fields: [receiverId], references: [id])

  payLink PayLink?

  @@map("payment_requests")
}

model BillSplit {
  id              String    @id @default(cuid())
  title           String
  description     String?
  totalAmount     Float
  status          String    @default("PENDING")
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  location        String?
  date            DateTime?
  note            String?
  splitMethod     String?
  paymentMethodId String?
  groupId         String?
  isRecurring     Boolean   @default(false)

  // Foreign keys
  createdBy String

  // Relationships
  creator           User                   @relation(fields: [createdBy], references: [id])
  group             Group?                 @relation(fields: [groupId], references: [id])
  transactions      Transaction[]
  participants      BillSplitParticipant[]
  items             BillItem[]
  receipts          Receipt[]
  invoices          Invoice[]
  reminders         BillSplitReminder[]
  recurring         RecurringBillSplit?
  paymentReferences PaymentReference[]

  @@map("bill_splits")
}

model BillItem {
  id          String @id @default(cuid())
  name        String
  price       Float
  quantity    Int
  billSplitId String

  billSplit BillSplit @relation(fields: [billSplitId], references: [id])

  @@map("bill_items")
}

model BillSplitParticipant {
  id     String  @id @default(cuid())
  amount Float
  status String  @default("PENDING")
  isPaid Boolean @default(false)

  // Foreign keys
  billSplitId String
  userId      String

  // Relationships
  billSplit BillSplit @relation(fields: [billSplitId], references: [id])
  user      User      @relation(fields: [userId], references: [id])

  @@unique([billSplitId, userId])
  @@map("bill_split_participants")
}

model BillSplitReminder {
  id          String   @id @default(cuid())
  billSplitId String
  senderId    String
  recipientId String
  type        String
  template    String?
  channels    String
  createdAt   DateTime @default(now())

  billSplit BillSplit @relation(fields: [billSplitId], references: [id], onDelete: Cascade)
  sender    User      @relation("BillSplitReminderSender", fields: [senderId], references: [id], onDelete: Cascade)
  recipient User      @relation("BillSplitReminderRecipient", fields: [recipientId], references: [id], onDelete: Cascade)

  @@map("bill_split_reminders")
}

model RecurringBillSplit {
  id          String   @id @default(cuid())
  billSplitId String   @unique
  frequency   String
  day         Int?
  nextRun     DateTime

  billSplit BillSplit @relation(fields: [billSplitId], references: [id])

  @@map("recurring_bill_splits")
}

model Friendship {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  // Foreign keys
  user1Id String
  user2Id String

  // Relationships
  user1 User @relation("User1", fields: [user1Id], references: [id])
  user2 User @relation("User2", fields: [user2Id], references: [id])

  @@unique([user1Id, user2Id])
  @@map("friendships")
}

model FriendRequest {
  id        String   @id @default(cuid())
  status    String   @default("PENDING")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Foreign keys
  senderId   String
  receiverId String

  // Relationships
  sender   User @relation("FriendRequestSender", fields: [senderId], references: [id])
  receiver User @relation("FriendRequestReceiver", fields: [receiverId], references: [id])

  @@unique([senderId, receiverId])
  @@map("friend_requests")
}

model Group {
  id          String   @id @default(cuid())
  name        String
  description String?
  color       String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  members     GroupMember[]
  accounts    GroupAccount[]
  invites     GroupInvite[]
  inviteLinks GroupInviteLink[]
  billSplits  BillSplit[]

  @@map("groups")
}

model GroupMember {
  groupId  String
  userId   String
  joinedAt DateTime @default(now())
  role     String   @default("MEMBER")

  group Group @relation(fields: [groupId], references: [id])
  user  User  @relation(fields: [userId], references: [id])

  @@id([groupId, userId])
  @@map("group_members")
}

model GroupInvite {
  id          String    @id @default(cuid())
  groupId     String
  name        String?
  contact     String
  method      String
  invitedBy   String
  invitedAt   DateTime  @default(now())
  status      String    @default("sent")
  expiresAt   DateTime
  attempts    Int       @default(1)
  lastAttempt DateTime?

  group Group @relation(fields: [groupId], references: [id])

  @@map("group_invites")
}

model GroupInviteLink {
  id          String   @id @default(cuid())
  groupId     String
  link        String
  createdAt   DateTime @default(now())
  expiresAt   DateTime
  maxUses     Int
  currentUses Int      @default(0)
  createdBy   String
  isActive    Boolean  @default(true)

  group Group @relation(fields: [groupId], references: [id])

  @@map("group_invite_links")
}

model GroupAccount {
  id            String   @id @default(cuid())
  groupId       String
  createdById   String
  name          String
  type          String
  accountType   String?
  bank          String?
  accountNumber String?
  accountName   String?
  sortCode      String?
  routingNumber String?
  provider      String?
  phoneNumber   String?
  isDefault     Boolean  @default(false)
  createdAt     DateTime @default(now())

  group     Group @relation(fields: [groupId], references: [id])
  createdBy User  @relation(fields: [createdById], references: [id])

  @@map("group_accounts")
}

model Notification {
  id          String   @id @default(cuid())
  recipientId String
  actorId     String?
  type        String
  title       String
  message     String
  read        Boolean  @default(false)
  actionable  Boolean  @default(false)
  amount      Float?
  createdAt   String   @default("")
  updatedAt   DateTime @updatedAt

  recipient User  @relation("NotificationRecipient", fields: [recipientId], references: [id])
  actor     User? @relation("NotificationActor", fields: [actorId], references: [id])

  @@map("notifications")
}

model NotificationPreference {
  id          String   @id @default(cuid())
  userId      String   @unique
  preferences String   @default("{}")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user User @relation(fields: [userId], references: [id])

  @@map("notification_preferences")
}

model SecurityLog {
  id         String   @id @default(cuid())
  userId     String
  action     String
  device     String?
  location   String?
  suspicious Boolean  @default(false)
  createdAt  DateTime @default(now())

  user User @relation(fields: [userId], references: [id])

  @@map("security_logs")
}

model PaymentMethod {
  id            String  @id @default(cuid())
  type          String
  bank          String?
  accountNumber String?
  accountName   String?
  sortCode      String?
  routingNumber String?
  accountType   String?
  provider      String?
  phoneNumber   String?
  isDefault     Boolean @default(false)
  userId        String

  user User @relation(fields: [userId], references: [id])
  payLinks PayLink[]

  @@map("payment_methods")
}

model PayLink {
  id                String    @id @default(cuid())
  userId            String
  paymentMethodId   String
  paymentRequestId  String?  @unique
  slug              String    @unique
  token             String    @unique
  title             String?
  message           String?
  amount            Float
  currency          String    @default("USD")
  status            String    @default("ACTIVE")
  recipientName     String?
  recipientEmail    String?
  recipientPhone    String?
  expiresAt         DateTime?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  user            User            @relation(fields: [userId], references: [id])
  paymentMethod   PaymentMethod   @relation(fields: [paymentMethodId], references: [id])
  paymentRequest  PaymentRequest? @relation(fields: [paymentRequestId], references: [id])

  @@map("pay_links")
}

model Receipt {
  id            String   @id @default(cuid())
  url           String
  metadata      String?
  transactionId String?
  billSplitId   String?
  createdAt     DateTime @default(now())

  transaction Transaction? @relation(fields: [transactionId], references: [id])
  billSplit   BillSplit?   @relation(fields: [billSplitId], references: [id])

  @@map("receipts")
}

model PaymentReference {
  id            String   @id @default(cuid())
  code          String   @unique
  userId        String
  billSplitId   String?
  transactionId String?
  used          Boolean  @default(false)
  createdAt     DateTime @default(now())

  user        User         @relation(fields: [userId], references: [id])
  billSplit   BillSplit?   @relation(fields: [billSplitId], references: [id])
  transaction Transaction? @relation(fields: [transactionId], references: [id])

  @@index([billSplitId])
  @@index([transactionId])
  @@map("payment_references")
}

model Invoice {
  id            String   @id @default(cuid())
  url           String
  metadata      String?
  transactionId String?
  billSplitId   String?
  createdAt     DateTime @default(now())

  transaction Transaction? @relation(fields: [transactionId], references: [id])
  billSplit   BillSplit?   @relation(fields: [billSplitId], references: [id])

  @@map("invoices")
}

model VerificationCode {
  id        String   @id @default(cuid())
  userId    String?
  type      String
  code      String
  target    String
  expiresAt DateTime

  user User? @relation(fields: [userId], references: [id])

  @@unique([userId, type])
  @@unique([target, type])
  @@index([expiresAt])
  @@map("verification_codes")
}
